sources:
  nginx_logs:
    type: file
    include:
      - "${NGINX_LOG_PATH:-/var/log/nginx/access.log}"

transforms:
  # 1) 통합 파싱 + 에러 분류
  parse_and_classify_errors:
    inputs:
      - nginx_logs
    type: remap
    source: |
      # 파싱
      . = parse_regex!(
        string!(.message),
        r'^(?P<remote_addr>\S+) - (?P<remote_user>\S+) \[(?P<time_local>[^\]]+)\] "(?P<request>[^"]+)" (?P<status>\d+) (?P<body_bytes_sent>\d+) "(?P<http_referer>[^"]*)" "(?P<http_user_agent>[^"]*)" "(?P<http_x_forwarded_for>[^"]*)" "(?P<request_time>[^"]*)" "(?P<http_x_request_id>[^"]*)" "(?P<http_x_cluster>[^"]*)" "(?P<http_x_cluster_dbuser>[^"]*)" "(?P<target_backend>[^"]*)"$'
      )

      # 타입 변환
      .status = to_int!(.status)
      .body_bytes_sent = to_int!(.body_bytes_sent)
      .request_time = to_float!(.request_time)
      
      # 에러 분류 및 필터링
      if .status == 499 {
        .error_type = "client_timeout"
        .error_class = "499"
        .alert_threshold = 5
      } else if .status >= 500 && .status <= 599 {
        .error_type = "server_error" 
        .error_class = "5xx"
        .alert_threshold = 10
      } else {
        # 에러가 아닌 로그는 버림
        abort
      }

  # 2) 통합 메트릭 생성
  unified_error_metrics:
    type: log_to_metric
    inputs:
      - parse_and_classify_errors
    metrics:
      - type: counter
        field: "status"
        name: "nginx_errors"
        tags:
          error_type: "{{ .error_type }}"
          error_class: "{{ .error_class }}"
          backend: "{{ .target_backend }}"

  # 3) 메트릭 집계
  error_aggregation:
    type: aggregate
    inputs:
      - unified_error_metrics
    interval_ms: 30000

  # 4) 메트릭을 로그로 변환
  metrics_to_logs:
    type: metric_to_log
    inputs: 
      - error_aggregation

  # 5) 알림 조건 필터링
  alert_filter:
    type: filter
    inputs:
      - metrics_to_logs
    condition: |
      threshold_499 = to_int!("${ALERT_499_THRESHOLD:-5}")
      threshold_5xx = to_int!("${ALERT_5XX_THRESHOLD:-10}")
      (.name == "nginx_errors") && ((.tags.error_type == "client_timeout" && to_int!(.counter.value) >= threshold_499) || (.tags.error_type == "server_error" && to_int!(.counter.value) >= threshold_5xx))

  # 6) 알림 메시지 포맷팅
  format_alert_message:
    type: remap
    inputs:
      - alert_filter
    source: |
      backend_full = to_string!(.tags.backend)
      backend = replace(backend_full, r'backend(\d+)', "$$1")
      count = to_string(to_int!(.counter.value))
      error_class = to_string!(.tags.error_class)
      
      cluster_group = "${CLUSTER_GROUP:-g1}"
      cluster_prefix = "${CLUSTER_PREFIX:-vc33}"
      server_type = "${SERVER_TYPE:-was1}"
      server_ip = "${SERVER_IP:-192.168.20.61}"
      interval_sec = to_int!("${AGGREGATION_INTERVAL_MS:-30000}") / 1000
      
      message_text = "⚠️ Vector 알림: [" + cluster_group + "] [*" + cluster_prefix + "-" + backend + "*] " + server_type + " (" + server_ip + ")] " + to_string(interval_sec) + "초 사이에 " + count + "개의 " + error_class + " 에러가 발생했습니다."

      . = { 
        "message": {
          "text": message_text,
          "type": "mrkdwn"
        }
      }

sinks:
  # 디버그 출력 - 알림 확인용
  debug_alerts:
    type: console
    inputs:
      - format_alert_message
    encoding:
      codec: json

  # Slack 알림 (현재 비활성화 - URL 문제로)
  slack_alert:
    type: http
    inputs: 
      - format_alert_message
    uri: "${SLACK_WEBHOOK_URL:-https://hooks.slack.com/services/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}"
    method: post
    encoding:
      codec: text
    batch:
      timeout_secs: 1
      max_events: 1
    request:
      headers:
        Content-Type: "application/json"