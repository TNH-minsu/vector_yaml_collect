sources:
  nginx_logs:
    type: file
    include:
      - /var/log/nginx/access.log

transforms:
  parse_nginx_logs:
    inputs:
      - "nginx_logs"
    type: "remap"
    source: |
      # 1) message 필드를 regex로 파싱해서 named group으로 가져오기
      . = parse_regex!(
      string!(.message),
          r'^(?P<remote_addr>\S+) - (?P<remote_user>\S+) \[(?P<time_local>[^\]]+)\] "(?P<request>[^"]+)" (?P<status>\d+) (?P<body_bytes_sent>\d+) "(?P<http_referer>[^"]*)" "(?P<http_user_agent>[^"]*)" "(?P<http_x_forwarded_for>[^"]*)" "(?P<request_time>[^"]*)" "(?P<http_x_request_id>[^"]*)" "(?P<http_x_cluster>[^"]*)" "(?P<http_x_cluster_dbuser>[^"]*)" "(?P<target_backend>[^"]*)"$'
      )

      # 2. 숫자 타입으로 변환
      .status                = to_int!(.status)
      .body_bytes_sent       = to_int!(.body_bytes_sent)
      .request_time          = to_float!(.request_time)
      
      # if exists(.tags) == false {
      #   .tags = {}
      # }

      # .tags.target_backend = .target_backend

  # 2) 5xx 에러만 필터링
  filter_5xx_errors:
    type: filter
    inputs:
      - parse_nginx_logs
    condition: |
      status = to_int!(.status)
      status >= 500 && status <= 599      
  
  # 3) 5[0-9]{2} 에러의 status code를 5xx으로 변환
  prepare_status_class:
    type: remap
    inputs:
      - filter_5xx_errors
    source: |
      .status_class = slice!(to_string!(.status), start: 0, end: 1) + "xx"

  # 2) 500 에러만 메트릭으로 변환
  errors_to_metrics:
    type: log_to_metric
    inputs:
      - prepare_status_class
    metrics:
      - type: counter
        field: "status"
        name: "nginx_http_500"  # 메트릭 이름
        #   host: "{{host}}"
        # condition: .status >= 500 && .status <= 599 
        tags:
          target_backend: "{{ .target_backend }}"
          status: "{{ .status_class }}"

  errors_500_agg:
    type: aggregate
    inputs:
      - errors_to_metrics
    interval_ms: 30000   # 30초 마다 flush
    mode: Sum            # incremental metrics 합산

  # debug_structure:
  #   type: remap
  #   inputs:
  #     - errors_500_agg
  #   source: |
  #     log(encode_json(.))

  # debug_count:
  #   type: remap
  #   inputs: [errors_500_agg]
  #   source: |
  #     if exists(.counter.value) {
  #       log("✅ FULL EVENT: " + encode_json(.))
  #     } else {
  #       log("⚠️ 빈 이벤트 수신됨")
  #     }

  metric_to_log_500_agg:
    type: metric_to_log
    inputs: [errors_500_agg]

  # debug_with_metric:
  #   type: remap
  #   inputs: [metric_to_log]
  #   source: |
  #     log("METRIC EVENT: " + encode_json(.))

  alert_500_log:
    type: filter
    inputs:
      - metric_to_log_500_agg
    condition: |
      .name == "nginx_http_500" && to_int!(.counter.value) >= 10

  wrap_slack_payload:
    type: remap
    inputs: [alert_500_log]
    source: |
      backend_full = to_string!(.tags.target_backend)
      backend = replace(backend_full, r'backend(\d+)', "$$1")
      count = to_string(to_int!(.counter.value))
      status = to_string!(.tags.status)
      
      message_text = "⚠️ Vector 알림: [g1] [*vc33-" + backend + "*] was1 (192.168.20.61)] 30초 사이에 구조에 " + count + "개의 " + status + " 에러가 발생했습니다."

      . = { 
        "message": {
          "text": message_text,
          "type": "mrkdwn"
        }
      }

sinks:
  # debug_parse_nginx_logs:
  #   type: console
  #   inputs:
  #     - debug_5xx
  #   encoding:
  #     codec: json

  slack_alert_simple:
    type: http
    inputs: [wrap_slack_payload]
    uri: "https://hooks.slack.com/services/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" # monit-alram
    # uri: "https://hooks.slack.com/services/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" # sms-test
    # uri: "http://localhost:8000/log"
    method: post

    encoding:
      codec: text

    # 요청을 1개씩 보내기
    batch:
      timeout_secs: 1
      max_events: 1

    request:
      headers:
        Content-Type: "application/json"